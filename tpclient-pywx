#! /usr/bin/env python

# Version check
try:
	import wxPython
	import string
	
	version = string.split(wxPython.__version__, '.')
	intversion = int(version[0])*1000000+int(version[1])*10000+int(version[2])*100

except ImportError:
	intversion = 0

if intversion < 2050000:
	print "Your version of wxPython is too old. You will not be able to run pywx-client."
	print "You have version", intversion
	print "You need version atleast", [2, 5, 0, 0]
	import sys
	sys.exit(1)
else:
	del wxPython
	del string

import sys

import gettext
gettext.install("pywx-client")

# wx.Python imports
import wx
import extra
#import extra.fixdc

# Python Imports
import time
from math import *
from copy import *
from types import *

import string
import pprint
import thread

try:
	import tp.netlib
except ImportError:
	import sys
	sys.path.append("..")
	import tp.netlib

from utils import *
from tp.netlib import Connection, failed, constants

from windows.control import MainControl

class Splash(wx.SplashScreen):
	def __init__(self, application):
		image = wx.Image("graphics/splash.png").ConvertToBitmap()
		wx.SplashScreen.__init__(self, image, wx.SPLASH_CENTRE_ON_SCREEN | wx.SPLASH_TIMEOUT, 3000, None, -1)

		self.application = application
		
		self.Bind(wx.EVT_CLOSE, self.OnClose)

	def OnClose(self, evt):
		self.Hide()
		time.sleep(1)
		self.application.windows.connect.Show(True)

class AppTP(wx.App):
	def __init__(self):
		wx.App.__init__(self)

		if wx.Platform in ('__WXMSW__', '__WXMAC__'):
			class Null(object):
				def write(self, *args, **kw):
					pass
				def flush(self, *args, **kw):
					pass
			sys.stdout = Null()

		try:
			wx.InitAllImageHandlers()
			self.config = self.ConfigLoad()
			self.windows = MainControl(self)
			self.connection = Connection()
			splash = Splash(self)
			splash.Show()

		except:
			do_traceback()

	def ConfigLoad(self):
		pass

	def ConfigSave(self):
		pass

	def CacheLoad(self):
		pass

	def CacheSave(self):
		pass

	def CacheUpdate(self):
		class Cache:
			def __init__(self):
				class ChangeDict(dict):
					def __init__(self):
						dict.__init__(self)
						self.times = {}
					
					def __setitem__(self, key, value):
						if type(value) is TupleType and len(value) == 2:
							self.times[key] = value[0]
							value = value[1]
						else:
							self.times[key] = -1
						dict.__setitem__(self, key, value)
				
					def __delitem__(self, key):
						del self.times[key]
						dict.__delitem__(self, key)
				
				# The object stuff
				self.objects		= ChangeDict()
				self.orders			= ChangeDict()
				self.orders_probe	= ChangeDict()

				# The message boards
				self.boards			= ChangeDict()
				self.messages		= ChangeDict()

				# Design stuff
				self.categories		= ChangeDict()
				self.designs		= ChangeDict()
				self.components		= ChangeDict()
				self.properties		= ChangeDict()

				self.players		= ChangeDict()
				self.resources		= ChangeDict()
		
		progress = wx.ProgressDialog("TP: Downloading Universe", "pywx-client is now downloading the Universe.", \
			100, self.windows.connect, wx.PD_APP_MODAL | wx.PD_AUTO_HIDE | wx.PD_ELAPSED_TIME | wx.PD_REMAINING_TIME)

		# Create the cache
		self.cache = Cache()

		# Get the features this server support
		features = self.connection.features()
		print "Features:", features
	
		# Boards and objects are special cases in which we have a sub-object to get
	
		# Get all the objects
		# -----------------------------------------------------------------------------------
		for id, time in self.connection.get_object_ids(iter=True):
			print "ID %i modified at %s" % (id, time)

			if not self.cache.objects.has_key(id) or time > self.cache.objects.times[id]:
				object = self.connection.get_objects(id=id)[0]
				print "Object:", object
			
				# Did we download the object okay?
				if failed(object):

					# Clean up the object
					if self.cache.objects.has_key(id):
						del self.cache.objects[id]

						if self.cache.orders.has_key(id):
							del self.cache.orders[id]
					continue

				self.cache.objects[id] = (time, object)

				# Download the orders from this object
				self.cache.orders[id] = []
				for order in self.connection.get_orders(id, range(0, object.order_number)):
					if failed(order):
						break
					self.cache.orders[id].append(order)

				# Download the orders probes
				self.cache.orders_probe[id] = []
				for otype in object.order_types:
					pass

			elif constants.FEATURE_ORDERED_OBJECT in features:
				break

		print "Objects ["
		for id,o in self.cache.objects.items():
			print " %s : %s ," % (id, o),
		print "]"

		# Get all the boards 
		# -----------------------------------------------------------------------------------
		for id, time in self.connection.get_board_ids(iter=True):

			if not self.cache.boards.has_key(id) or time > self.cache.boards.times[id]:
				board = self.connection.get_boards(id=id)[0]

				# Did we download the board okay?
				if failed(board):
					
					# Clean up the board
					if self.cache.boards.has_key(id):
						del self.cache.boards[id]

						if self.cache.messages.has_key(id):
							del self.cache.messages[id]
					continue

				self.cache.boards[id] = (time, board)

				# Download the orders from this object
				self.cache.messages[id] = []
				for message in self.connection.get_messages(id, range(0, board.number)):
					if failed(message):
						break
					self.cache.messages[id].append(message)

			elif constants.FEATURE_ORDERED_BOARD in features:
				break

		print "Boards ["
		for id,o in self.cache.boards.items():
			print " %s : %s ," % (id, o)
		print "]"


		# Get all the order descriptions
		# -----------------------------------------------------------------------------------
		for id, time in self.connection.get_orderdesc_ids(iter=True):
##			if not self.cache..has_key(id) or time > self.cache.boards.times[id]:
				desc = self.connection.get_orderdescs(id=id)[0]

				# Did we download the board okay?
				if failed(desc):
					desc.register()

		def get_all(get_ids, get, cache, feature):
			for id, time in get_ids(iter=True):
				if not cache.has_key(id) or time > cache.times[id]:
					frame = get(id=id)[0]

					# Did we download the board okay?
					if failed(frame):
						print "Failed to get %i removing" % id
						if cache.has_key(id):
							del cache[id]
						continue

					cache[id] = (time, frame)

				elif feature in features:
					break

			print "[",
			for object in cache.values():
				print " <'%s' %i>" % (object.name, object.id)
			print "]"

		get_all(self.connection.get_resource_ids, self.connection.get_resources, 
					self.cache.resources, constants.FEATURE_ORDERED_RESOURCE)

		get_all(self.connection.get_category_ids, self.connection.get_categories, 
					self.cache.categories, constants.FEATURE_ORDERED_CATEGORY)

		get_all(self.connection.get_design_ids, self.connection.get_designs, 
					self.cache.designs, constants.FEATURE_ORDERED_DESIGN)
					
		get_all(self.connection.get_component_ids, self.connection.get_components, 
					self.cache.components, constants.FEATURE_ORDERED_COMPONENT)
		
		get_all(self.connection.get_property_ids, self.connection.get_properties, 
					self.cache.properties, constants.FEATURE_ORDERED_PROPERTY)
				
		progress.Update(100)
		self.windows.Post(wx.local.CacheUpdateEvent())
		return

	def Exit(self):
		print "AppTp.exit"
		sys.exit(1)

if __name__ == '__main__':
	try:
		app = AppTP()
		app.MainLoop()
	finally:
		do_traceback()
		sys.stdin.read(1)
	
