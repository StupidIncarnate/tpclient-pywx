#! /usr/bin/env python

# Version check
try:
	import wxPython
	import string
	
	version = string.split(wxPython.__version__, '.')
	intversion = int(version[0])*1000000+int(version[1])*10000+int(version[2])*100

except ImportError:
	intversion = 0

if intversion < 2050000:
	print "Your version of wxPython is too old. You will not be able to run pywx-client."
	print "You have version", intversion
	print "You need version atleast", [2, 5, 0, 0]
	import sys
	sys.exit(1)
else:
	del wxPython
	del string

import sys

import gettext
gettext.install("pywx-client")

# wx.Python imports
import wx
import extra
#import extra.fixdc

# Python Imports
import time
from math import *
from copy import *
from types import *

import string
import pprint
import thread

try:
	import tp.netlib
except ImportError:
	import sys
	sys.path.append("..")
	import tp.netlib

from utils import *
from tp.netlib import Connection, failed, constants

from windows.control import MainControl

class Splash(wx.SplashScreen):
	def __init__(self, application):
		image = wx.Image("graphics/splash.png").ConvertToBitmap()
		wx.SplashScreen.__init__(self, image, wx.SPLASH_CENTRE_ON_SCREEN | wx.SPLASH_TIMEOUT, 3000, None, -1)

		self.application = application
		
		self.Bind(wx.EVT_CLOSE, self.OnClose)

	def OnClose(self, evt):
		self.Hide()
		time.sleep(1)
		self.application.windows.connect.Show(True)

class AppTP(wx.App):
	def __init__(self):
		wx.App.__init__(self)

		if wx.Platform in ('__WXMSW__', '__WXMAC__'):
			class Null(object):
				def write(self, *args, **kw):
					pass
				def flush(self, *args, **kw):
					pass
			sys.stdout = Null()

		try:
			wx.InitAllImageHandlers()
			self.config = self.ConfigLoad()
			self.windows = MainControl(self)
			self.connection = Connection()
			splash = Splash(self)
			splash.Show()

		except:
			do_traceback()

	def ConfigLoad(self):
		pass

	def ConfigSave(self):
		pass

	def CacheLoad(self):
		pass

	def CacheSave(self):
		pass

	def CacheUpdate(self):
		class Cache:
			def __init__(self):
				class ChangeDict(dict):
					def __init__(self):
						dict.__init__(self)
						self.times = {}
					
					def __setitem__(self, key, value):
						if type(value) is TupleType and len(value) == 2:
							self.times[key] = value[0]
							value = value[1]
						else:
							self.times[key] = -1
						dict.__setitem__(self, key, value)
				
					def __delitem__(self, key):
						del self.times[key]
						dict.__delitem__(self, key)
				
				# The object stuff
				self.objects		= ChangeDict()
				self.orders			= ChangeDict()
				self.orders_probe	= ChangeDict()

				# The message boards
				self.boards			= ChangeDict()
				self.messages		= ChangeDict()

				self.categories		= ChangeDict()
				self.components		= ChangeDict()

				self.players		= ChangeDict()
				self.resources		= ChangeDict()
		
		progress = wx.ProgressDialog("TP: Downloading Universe", "pywx-client is now downloading the Universe.", \
			100, self.windows.connect, wx.PD_APP_MODAL | wx.PD_AUTO_HIDE | wx.PD_ELAPSED_TIME | wx.PD_REMAINING_TIME)

		# Create the cache
		self.cache = Cache()

		# Get the features this server support
		features = self.connection.features()
		print "Features:", features
		
		# Get all the objects
		# -----------------------------------------------------------------------------------
		for id, time in self.connection.get_object_ids(iter=True):
			print "ID %i modified at %s" % (id, time)

			if not self.cache.objects.has_key(id) or time > self.cache.objects.times[id]:
				object = self.connection.get_objects(id=id)[0]
				print "Object:", object
			
				# Did we download the object okay?
				if failed(object):

					# Clean up the object
					if self.cache.objects.has_key(id):
						del self.cache.objects[id]

						if self.cache.orders.has_key(id):
							del self.cache.orders[id]
					continue

				self.cache.objects[id] = (time, object)

				# Download the orders from this object
				self.cache.orders[id] = []
				for order in self.connection.get_orders(id, range(0, object.order_number)):
					if failed(order):
						break
					self.cache.orders[id].append(order)

				# Download the orders probes
				self.cache.orders[id] = []
				for otype in object.order_types:
					pass

			elif constants.FEATURE_ORDERED_OBJECT in features:
				break

		print "Objects ["
		for id,o in self.cache.objects.items():
			print " %s : %s ," % (id, o)
		print "]"

		# Get all the boards 
		# -----------------------------------------------------------------------------------
		for time, id in self.connection.get_board_ids(iter=True):

			if not self.cache.boards.has_key(id) or time > self.cache.boards.times[id]:
				board = self.connection.get_boards(id=id)

				# Did we download the board okay?
				if failed(board):
					
					# Clean up the board
					if self.cache.boards.has_key(id):
						del self.cache.boards[id]

						if self.cache.messages.has_key(id):
							del self.cache.messages[id]
					continue

				self.cache.boards[id] = (time, board)

				# Download the orders from this object
				self.cache.messages[id] = []
				for message in self.connection.get_messages(id, range(0, board.number)):
					if failed(message):
						break
					self.cache.messages[id].append(message)

			elif constants.FEATURE_ORDERED_BOARD in features:
				break

		print "Boards ["
		for id,o in self.cache.boards.items():
			print " %s : %s ," % (id, o)
		print "]"
		
##		# Get all the resource desciptions
##		# -----------------------------------------------------------------------------------
##		for time, id in self.connection.get_resource_ids(iter=True):
##
##			if not self.cache.resources.has_key(id) or time > self.cache.resources.times[id]:
##				resource = self.connection.get_resources(id=id)
##
##				# Did we download the object okay?
##				if failed(resource):
##
##					# Clean up the resource
##					if self.cache.resources.has_key(id):
##						del self.cache.resources[id]
##					continue
##
##				self.cache.resources[id] = (time, resource)
##
##			elif constants.FEATURE_ORDERED_RESOURCE in features:
##				break
##

		# Get all the component
		# -----------------------------------------------------------------------------------
		progress.Update(100)
		self.windows.Post(wx.local.CacheUpdateEvent())

		return
		


		# Download any order descriptions not already downloaded
		descs = []
		while True:
			r = self.connection.get_orderdescs(len(descs))[0]
			if not failed(r):
				descs.append(r)
				descs[-1].register()
			else:
				break

		# Download the categories
		for category in self.connection.get_categories([]):
			if failed(category):
				continue

			self.cache.categories[category.id] = category

		# Download the components
		for component in self.connection.get_components([]):
			if failed(component):
				continue
			
			self.cache.components[component.id] = component

		progress.Update(100)
		self.windows.Post(wx.local.CacheUpdateEvent())

		# Get the time remaining
		seconds = self.connection.time()
		print seconds
		if not failed(seconds):
			import time
			self.windows.main.statusbar.SetEndTime(time.time() + seconds[1] - 5)

##		# Download objects
##		objects = self.connection.get_objects(0)
##		while len(objects) > 0:
##			object = objects.pop(0)
##			
##			if failed(object):
##				print object
##				continue
##			
##			self.cache.objects[object.id] = object
##			
##			# Download the objects inside this object
##			if len(object.contains) > 0:
##				# Set the parent relationship
##				nobjects = self.connection.get_objects(object.contains)
##				for nobject in nobjects:
##					if failed(nobject):
##						print nobject
##						continue
##					else:
##						nobject.parent = object.id
##					objects.append(nobject)
##
##			# Download the orders from this object
##			self.cache.orders[object.id] = []
##			if object.order_number != 0:
##				for order in self.connection.get_orders(object.id, range(0, object.order_number)):
##					if failed(order):
##						break
##					self.cache.orders[object.id].append(order)
##
##			# Download the orders probes
##			self.cache.orders[object.id] = []
##			for type in object.order_types:
##				pass
##
##			progress.Update(len(self.cache.objects.keys()))
##
##
##		# Download message boards
##		for board in self.connection.get_boards([]):
##			if failed(board):
##				continue
##
##			# Download the messages from this board
##			if board.number == 0:
##				messages = []
##			elif board.number == 1:
##				messages = self.connection.get_messages(board.id, range(0, board.number))
##				if not hasattr(messages, "__getitem__"):
##					messages = [messages]
##				else:
##					messages = list(messages)
##			else:
##				messages = self.connection.get_messages(board.id, range(0, board.number))
##
##			self.cache.messages[board.id] = list(messages)

	def Exit(self):
		print "AppTp.exit"
		sys.exit(1)

if __name__ == '__main__':
	try:
		app = AppTP()
		app.MainLoop()
	finally:
		do_traceback()
		sys.stdin.read(1)
	
